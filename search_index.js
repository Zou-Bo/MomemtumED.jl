var documenterSearchIndex = {"docs":
[{"location":"physics/#Physics-Implementation","page":"Physics Background","title":"Physics Implementation","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"This document describes the physics concepts implemented in the package.","category":"page"},{"location":"physics/#Momentum-Conservation","page":"Physics Background","title":"Momentum Conservation","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The package exploits translational symmetry to block-diagonalize the Hamiltonian by total momentum sectors. A momemtum-unconserved Hamiltonian will cause errors.","category":"page"},{"location":"physics/#Block-Division","page":"Physics Background","title":"Block Division","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The Hilbert space is divided into blocks with identical total momentum:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"blocks, block_k1, block_k2, k0number = ED_momentum_block_division(para, mbs_list)","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"This reduces the eigenvalue problem size from the full Hilbert space to individual momentum blocks.","category":"page"},{"location":"physics/#Many-Body-State-Representation","page":"Physics Background","title":"Many-Body State Representation","text":"","category":"section"},{"location":"physics/#Bit-Encoding","page":"Physics Background","title":"Bit Encoding","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Many-body states are represented using bit strings:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"struct MBS64{bits} <: Integer\n    n::UInt64\nend","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Each bit represents orbital occupation (0 = empty, 1 = occupied)\nbits parameter determines maximum system size (up to 64 orbitals)\nEfficient bitwise operations for state manipulation","category":"page"},{"location":"physics/#State-Operations","page":"Physics Background","title":"State Operations","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The MBS64 type provides basic operations for bit manipulation:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"# Create a 4-bit state with orbitals 1 and 3 occupied\nmbs = MBS64{4}(0b1010)  # Binary representation\n\n# Access the underlying integer\nstate_value = mbs.n","category":"page"},{"location":"physics/#Hamiltonian-Construction","page":"Physics Background","title":"Hamiltonian Construction","text":"","category":"section"},{"location":"physics/#Scattering-Formalism","page":"Physics Background","title":"Scattering Formalism","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The Hamiltonian is constructed using abstract N-body scattering terms:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"struct Scattering{N}\n    Amp::ComplexF64\n    out::NTuple{N, Int64}\n    in::NTuple{N, Int64}\nend\n\n# One-body: V * c†_i c_j\ns1 = Scattering(1.0-1.0im, 1, 2)  # Creates c†_1 c_2 term\n\n# Two-body: V * c†_i1 c†_i2 c_j2 c_j1  \ns2 = Scattering(0.5, 1, 2, 4, 3)  # Creates c†_1 c†_2 c_4 c_3 term","category":"page"},{"location":"physics/#Scattering-List-Generation","page":"Physics Background","title":"Scattering List Generation","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The package generates sorted lists of scattering terms:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"# One-body terms from EDPara.H_onebody matrix\nscat_list1 = ED_sortedScatteringList_onebody(para)\n\n# Two-body terms from interaction function\nscat_list2 = ED_sortedScatteringList_twobody(para)","category":"page"},{"location":"physics/#Multi-Component-Systems","page":"Physics Background","title":"Multi-Component Systems","text":"","category":"section"},{"location":"physics/#Component-Indexing","page":"Physics Background","title":"Component Indexing","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The package handles additional quantum numbers beyond momentum:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"# Global orbital index mapping\nglobal_index = k + Nk * (ch - 1) + Nk * Nch * (cc - 1)","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Where:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"k: momentum index (1 to Nk)\nch: hopping channel index (1 to Nc_hopping)\ncc: conserved component index (1 to Nc_conserve)","category":"page"},{"location":"physics/#One-body-Terms","page":"Physics Background","title":"One-body Terms","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Stored in 4D array: H_onebody[ch1, ch2, cc, k]","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Represents hopping between channels ch2 → ch1\nConserves component index cc\nMomentum index k is conserved","category":"page"},{"location":"physics/#Two-body-Interactions","page":"Physics Background","title":"Two-body Interactions","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Custom interaction functions receive momentum coordinates and component indices:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"function V_int(k_coords_f1, k_coords_f2, k_coords_i1, k_coords_i2, cf1=1, cf2=1, ci1=1, ci2=1)\n    # k_coords_*: Tuple{Float64, Float64} momentum coordinates\n    # cf1, cf2: final component indices\n    # ci1, ci2: initial component indices\n    # Return complex scattering amplitude\nend","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The function receives momentum coordinates already shifted and normalized by the Gk vector.","category":"page"},{"location":"physics/#Entanglement-Entropy","page":"Physics Background","title":"Entanglement Entropy","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The package computes entanglement entropy for bit-position bipartitions:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"# Create bit mask for subsystem A (first 2 bits)\nbit_mask = MBS64{bits}(0b0011)\n\n# Compute entanglement entropy\nentropy = ED_etg_entropy(block, eigenvector, bit_mask)\n\n# Rényi entropy of order 2\nentropy_2 = ED_etg_entropy(block, eigenvector, bit_mask, alpha=2.0)","category":"page"},{"location":"physics/#Implementation","page":"Physics Background","title":"Implementation","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Uses bit masking to identify subsystem A and B\nDirect computation without storing reduced density matrix\nComputes von Neumann entropy: S = -Tr(ρ_A log ρ_A)\nSupports Rényi entropy: S_α = (1-α)^(-1) log Tr(ρ_A^α)\nAutomatically computes RDM for smaller subsystem for efficiency","category":"page"},{"location":"physics/#Berry-Connection","page":"Physics Background","title":"Berry Connection","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"For topological analysis, the package computes many-body Berry connections between kshift points:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"# Calculate geometric phase between two kshift points\ngeometric_phase = ED_connection_integral(kshift1, kshift2, ψ1, ψ2, momentum_axis_angle)\n\n# Calculate Berry connection (average connection)\nberry_conn = ED_connection_integral(kshift1, kshift2, ψ1, ψ2, momentum_axis_angle; average_connection=true)","category":"page"},{"location":"physics/#Implementation-2","page":"Physics Background","title":"Implementation","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Computes complex inner product: ⟨ψ2|ψ1⟩\nExtracts geometric phase: φ = arg(⟨ψ2|ψ1⟩)\nBerry connection: A = φ / ||δk||\nAccounts for non-orthogonal momentum space coordinates\nHandles numerical stability for very close points","category":"page"},{"location":"physics/#KrylovKit-Integration","page":"Physics Background","title":"KrylovKit Integration","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The package uses KrylovKit for sparse matrix diagonalization:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"# Sparse matrix construction from scattering terms\nH = HmltMatrix_threaded(block, scat_list1, scat_list2, multi_thread)\n\n# KrylovKit eigensolve\nvals, vecs, info = eigsolve(H, vec0, N_eigen, :SR, ishermitian=true)","category":"page"},{"location":"physics/#Convergence-Control","page":"Physics Background","title":"Convergence Control","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The eigensolver includes:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Random initial vector for good convergence\nConvergence warning system\nSupport for different eigenvalue selections (:SR, :LR, :LM)\nAutomatic handling of convergence failures","category":"page"},{"location":"physics/#Momentum-Mesh-Shift","page":"Physics Background","title":"Momentum Mesh Shift","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"The package supports twisted boundary conditions via k-mesh shift:","category":"page"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"# Apply momentum shift to interaction amplitudes\namp = int_amp(i1, i2, f1, f2, para; kshift=(0.1, 0.2))","category":"page"},{"location":"physics/#Implementation-3","page":"Physics Background","title":"Implementation","text":"","category":"section"},{"location":"physics/","page":"Physics Background","title":"Physics Background","text":"Shifts momentum coordinates: (k_list .+ kshift) ./ Gk\nMaintains backward compatibility with default (0.0, 0.0)\nAffects all momentum-dependent calculations in interaction functions","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Data-Structures","page":"API Reference","title":"Core Data Structures","text":"","category":"section"},{"location":"api/#EDPara","page":"API Reference","title":"EDPara","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Central parameter container for system configuration.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Constructor:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"k_list::Matrix{Int64}: Momentum point represented by integers\nGk::Tuple{Int64, Int64}: Reciprocal lattice constant in integers; zero means no Umklapp scattering (default (0,0))\nNc_conserve::Int64: Number of conserved components (default 1)\nNc_hopping::Int64: Number of hopping channels (default 1)\nV_int::Function: Two-body interaction function\nH_onebody::Array{ComplexF64, 4}: One-body Hamiltonian terms, index [ch1, ch2, cc, k]","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"EDPara(; k_list, Gk, V_int, H_onebody=zeros(ComplexF64, 1, 1, 1, 1))","category":"page"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#System-Setup","page":"API Reference","title":"System Setup","text":"","category":"section"},{"location":"api/#ED*mbslist(para::EDPara,-N*particles)","page":"API Reference","title":"EDmbslist(para::EDPara, Nparticles)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Generate all many-body states for given particle number.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"para::EDPara: System parameters\nN_particles: Number of particles (tuple for each-component)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{MBS64}: List of many-body states","category":"page"},{"location":"api/#ED*momentum*block*division(para::EDPara,-mbs*list)","page":"API Reference","title":"EDmomentumblockdivision(para::EDPara, mbslist)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Divide Hilbert space into momentum blocks.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"para::EDPara: System parameters\nmbs_list::Vector{MBS64}: List of many-body states","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"`blocks::Vector{Vector{MBS64}}: States in each momentum block\nblock_k1::Vector{Int64}: K1 momentum for each block\nblock_k2::Vector{Int64}: K2 momentum for each block\nk0number::Int64: Index of momentum=0 block","category":"page"},{"location":"api/#Hamiltonian-Construction","page":"API Reference","title":"Hamiltonian Construction","text":"","category":"section"},{"location":"api/#ED*sortedScatteringList*onebody(para::EDPara)","page":"API Reference","title":"EDsortedScatteringListonebody(para::EDPara)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Generate sorted list of one-body scattering terms.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"para::EDPara: System parameters","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{Scattering{1}}: Sorted one-body scattering terms","category":"page"},{"location":"api/#ED*sortedScatteringList*twobody(para::EDPara)","page":"API Reference","title":"EDsortedScatteringListtwobody(para::EDPara)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Generate sorted list of two-body scattering terms.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"para::EDPara: System parameters","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{Scattering{2}}: Sorted two-body scattering terms","category":"page"},{"location":"api/#Diagonalization","page":"API Reference","title":"Diagonalization","text":"","category":"section"},{"location":"api/#EDsolve(block,-scat*list1,-scat*list2,-Neigen;-kwargs)","page":"API Reference","title":"EDsolve(block, scatlist1, scatlist2, Neigen; kwargs)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Solve eigenvalue problem for momentum block.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"block::Vector{MBS64}: Many-body states in block\nscat_list1::Vector{Scattering{1}}: One-body scattering terms\nscat_list2::Vector{Scattering{2}}: Two-body scattering terms\nNeigen::Int64: Number of eigenvalues to compute","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Keyword Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"showtime::Bool=false: Show timing information\nconverge_warning::Bool=true: Show convergence warnings\nwhich::Symbol=:SR: Which eigenvalues to compute (:SR, :LR, :LM)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"values::Vector{Float64}: Eigenvalues\nvectors::Vector{Vector{ComplexF64}}: Eigenvectors","category":"page"},{"location":"api/#Analysis-Functions","page":"API Reference","title":"Analysis Functions","text":"","category":"section"},{"location":"api/#ED*etg*entropy(eigenvectors,-block,-partition_indices)","page":"API Reference","title":"EDetgentropy(eigenvectors, block, partition_indices)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Calculate entanglement entropy for spatial partition.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"eigenvectors::Vector{Vector{ComplexF64}}: Eigenvectors\nblock::Vector{MBS64}: Many-body states in block\npartition_indices::Vector{Int64}: Orbital indices for partition A","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{Float64}: Entanglement entropy for each eigenvector","category":"page"},{"location":"api/#ED*connection*integral(para,-eigenvectors,-blocks,-block*k1,-block*k2)","page":"API Reference","title":"EDconnectionintegral(para, eigenvectors, blocks, blockk1, blockk2)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Calculate many-body Berry connection.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"para::EDPara: System parameters\neigenvectors::Matrix{Vector{ComplexF64}}: All eigenvectors\nblocks::Vector{Vector{MBS64}}: All momentum blocks\nblock_k1::Vector{Int64}: K1 momenta\nblock_k2::Vector{Int64}: K2 momenta","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Matrix{ComplexF64}: Berry connection matrix","category":"page"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#ED*occupancy*to*momentum(occupancy,-k*list,-Gk)","page":"API Reference","title":"EDoccupancytomomentum(occupancy, klist, Gk)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Convert occupancy array to momentum representation.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"occupancy::Vector{Int64}: Occupation numbers\nk_list::Matrix{Int64}: Momentum point indices\nGk::Tuple{Int64, Int64}: Grid dimensions","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{ComplexF64}: Momentum space wavefunction","category":"page"},{"location":"api/#group*momentum*pairs(k_list,-Gk)","page":"API Reference","title":"groupmomentumpairs(k_list, Gk)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Group momentum pairs for efficient scattering calculations.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Arguments:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"k_list::Matrix{Int64}: Momentum point indices\nGk::Tuple{Int64, Int64}: Grid dimensions","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Returns:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Vector{Tuple{Int64, Int64, Int64}}: Grouped momentum pairs","category":"page"},{"location":"api/#Multi-Component-Systems","page":"API Reference","title":"Multi-Component Systems","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The package supports multi-component systems with separate conservation laws:","category":"page"},{"location":"api/#Component-Indexing","page":"API Reference","title":"Component Indexing","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Global orbital index: i_global = k + Nk * (ch - 1) + Nk * Nch * (cc - 1)\nk: momentum index\nch: hopping channel index\ncc: conserved component index","category":"page"},{"location":"api/#One-Body-Terms","page":"API Reference","title":"One-Body Terms","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Accessed via para.H_onebody[ch1, ch2, cc, k] for hopping between channels.","category":"page"},{"location":"api/#Two-Body-Terms","page":"API Reference","title":"Two-Body Terms","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Handled by the interaction function para.V_int with proper component mapping.","category":"page"},{"location":"api/#Performance-Tips","page":"API Reference","title":"Performance Tips","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pre-computation: Generate scattering lists once and reuse for all momentum blocks\nMemory Management: Use showtime=true to monitor memory usage\nParallel Processing: The package automatically uses multiple threads when available\nSparse Methods: KrylovKit eigensolvers are memory-efficient for large systems","category":"page"},{"location":"api/#Error-Handling","page":"API Reference","title":"Error Handling","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The package validates inputs and provides descriptive error messages for:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Invalid momentum indices\nInconsistent system parameters\nMemory allocation failures\nConvergence issues in eigensolvers","category":"page"},{"location":"performance/#Performance-Guide","page":"Performance Guide","title":"Performance Guide","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"This document describes performance characteristics and optimization strategies implemented in the package.","category":"page"},{"location":"performance/#Memory-Efficiency","page":"Performance Guide","title":"Memory Efficiency","text":"","category":"section"},{"location":"performance/#Bit-Based-State-Representation","page":"Performance Guide","title":"Bit-Based State Representation","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"The package uses bit-encoded many-body states to minimize memory usage:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"struct MBS64{bits} <: Integer\n    n::UInt64  # 64-bit integer for up to 64 orbitals\nend","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Memory Usage: ","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Each MBS64 state: 8 bytes (regardless of system size)\nN-orbital system: N × 8 bytes for complete basis\nCompared to explicit state vectors: significant memory reduction","category":"page"},{"location":"performance/#Sparse-Matrix-Storage","page":"Performance Guide","title":"Sparse Matrix Storage","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Hamiltonian matrices use sparse storage.","category":"page"},{"location":"performance/#Computational-Efficiency","page":"Performance Guide","title":"Computational Efficiency","text":"","category":"section"},{"location":"performance/#Momentum-Block-Division","page":"Performance Guide","title":"Momentum Block Division","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"The package reduces computational complexity through momentum conservation:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Divide Hilbert space into momentum blocks\nblocks, block_k1, block_k2, k0number = ED_momentum_block_division(para, mbs_list)","category":"page"},{"location":"performance/#Scattering-Formalism","page":"Performance Guide","title":"Scattering Formalism","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Hamiltonian construction uses scattering terms:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Generate sorted scattering lists\nscat_list1 = ED_sortedScatteringList_onebody(para)\nscat_list2 = ED_sortedScatteringList_twobody(para)","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Advantages:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Avoids explicit matrix element storage\nEfficient term generation and sorting\nAutomatic Hermitian symmetry handling","category":"page"},{"location":"performance/#KrylovKit-Integration","page":"Performance Guide","title":"KrylovKit Integration","text":"","category":"section"},{"location":"performance/#Sparse-Eigenvalue-Solvers","page":"Performance Guide","title":"Sparse Eigenvalue Solvers","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"The package uses KrylovKit for efficient sparse diagonalization:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Krylov subspace methods\nvals, vecs, info = eigsolve(H, vec0, N_eigen, :SR, ishermitian=true)","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Performance Benefits:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Only computes requested eigenvalues (not full spectrum)\nMemory-efficient for large sparse matrices\nIterative methods with configurable convergence","category":"page"},{"location":"performance/#Convergence-Control","page":"Performance Guide","title":"Convergence Control","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Convergence monitoring and warnings\nif !(info.converged == true || info.converged == 1)\n    @warn \"Eigensolver did not converge. Residual norm: $(info.normres)\"\nend","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Features:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Automatic convergence detection\nResidual norm monitoring\nConfigurable tolerance levels","category":"page"},{"location":"performance/#Multi-threading","page":"Performance Guide","title":"Multi-threading","text":"","category":"section"},{"location":"performance/#Parallel-Hamiltonian-Construction","page":"Performance Guide","title":"Parallel Hamiltonian Construction","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"The package supports multi-threaded matrix construction:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Threaded sparse matrix assembly\nH = HmltMatrix_threaded(block, scat_list1, scat_list2, multi_thread)","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Implementation:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Julia Threads.@threads for parallelization thread-local matrix construction\nFinal assembly with thread safety","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Performance Scaling:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Linear scaling with number of CPU cores\nAutomatic thread pool management","category":"page"},{"location":"performance/#Efficient-Data-Structures","page":"Performance Guide","title":"Efficient Data Structures","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Key data structure choices:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Vectors for dynamic collections\nTuples for fixed-size indexing\nComplexF64 for quantum amplitudes\nUInt64 for bit operations","category":"page"},{"location":"performance/#Algorithmic-Optimizations","page":"Performance Guide","title":"Algorithmic Optimizations","text":"","category":"section"},{"location":"performance/#Sorted-Scattering-Lists","page":"Performance Guide","title":"Sorted Scattering Lists","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Scattering terms are sorted and merged.","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Benefits:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Eliminates duplicate terms\nEnables efficient term lookup\nImproves cache locality","category":"page"},{"location":"performance/#Performance-Monitoring","page":"Performance Guide","title":"Performance Monitoring","text":"","category":"section"},{"location":"performance/#Timing-Information","page":"Performance Guide","title":"Timing Information","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"The package includes timing capabilities:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Enable timing output\nenergies, eigenvectors = EDsolve(block, scat_list1, scat_list2, N_eigen; showtime=true)","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Output:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Matrix construction time\nDiagonalization time","category":"page"},{"location":"performance/#Convergence-Monitoring","page":"Performance Guide","title":"Convergence Monitoring","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Track eigensolver convergence:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Enable convergence warnings\nenergies, eigenvectors = EDsolve(block, scat_list1, scat_list2, N_eigen; converge_warning=true)","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Features:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Residual norm reporting\nConvergence failure warnings\nAutomatic fallback strategies","category":"page"},{"location":"performance/#Scaling-Characteristics","page":"Performance Guide","title":"Scaling Characteristics","text":"","category":"section"},{"location":"performance/#System-Size-Scaling","page":"Performance Guide","title":"System Size Scaling","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"The package scales with:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Orbitals: Up to 64 (bit encoding limit)\nParticles: Limited by combinatorial growth\nMomentum blocks: Number depends on system symmetry","category":"page"},{"location":"performance/#Memory-Scaling","page":"Performance Guide","title":"Memory Scaling","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Typical memory usage:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"State storage: O(N_states × 8 bytes)\nHamiltonian: O(N_nonzero × sizeof(ComplexF64))\nEigenvectors: O(Nstates × Neigen × sizeof(ComplexF64))","category":"page"},{"location":"performance/#Computational-Scaling","page":"Performance Guide","title":"Computational Scaling","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Diagonalization complexity:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Full diagonalization: O(d³) where d is block dimension\nKrylov methods: O(d × N_eigen × iterations)\nMatrix construction: O(Nterms × Nstates)","category":"page"},{"location":"performance/#Configuration-Options","page":"Performance Guide","title":"Configuration Options","text":"","category":"section"},{"location":"performance/#Thread-Control","page":"Performance Guide","title":"Thread Control","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Configure multi-threading usage:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Enable/disable multi-threading\nenergies, eigenvectors = EDsolve(block, scat_list1, scat_list2, N_eigen; multi_thread=true)","category":"page"},{"location":"performance/#Convergence-Settings","page":"Performance Guide","title":"Convergence Settings","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Control eigensolver behavior:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Convergence and warning settings\nenergies, eigenvectors = EDsolve(block, scat_list1, scat_list2, N_eigen; \n                                  converge_warning=true, showtime=false)","category":"page"},{"location":"performance/#Memory-Optimization","page":"Performance Guide","title":"Memory Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Optimize memory usage patterns:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Use appropriate block sizes\nLimit number of requested eigenvalues\nEnable memory-efficient sparse formats","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section describes the example notebooks included with the package.","category":"page"},{"location":"examples/#Example-1:-FQH-Laughlin-State","page":"Examples","title":"Example 1: FQH Laughlin State","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"File: examples/example1_FQH_Laughlin.ipynb","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This notebook demonstrates the implementation of fractional quantum Hall effect calculations using the momentum-conserved exact diagonalization method.","category":"page"},{"location":"examples/#System-Setup","page":"Examples","title":"System Setup","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example implements a 3×5 triangular lattice k-mesh with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"15 k-points total (multiple of 3 for 1/3 filling)\n5 electrons for ν = 1/3 filling\nLandau level projection with magnetic length scale\nScreened Coulomb interaction with form factor","category":"page"},{"location":"examples/#Key-Functions-Used","page":"Examples","title":"Key Functions Used","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Parameter structure with k-mesh\npara = EDPara(k_list=k_list, Gk=Gk, V_int=V_int)\n\n# State generation and momentum blocking\nmbs_list = ED_mbslist(para, Ne)\nblocks, block_k1, block_k2, k0number = ED_momentum_block_division(para, mbs_list)\n\n# Scattering list generation\nscat_list1 = ED_sortedScatteringList_onebody(para)\nscat_list2 = ED_sortedScatteringList_twobody(para)\n\n# KrylovKit diagonalization\nenergies, eigenvectors = EDsolve(blocks[1], scat_list1, scat_list2, 5)","category":"page"},{"location":"examples/#Physics-Implementation","page":"Examples","title":"Physics Implementation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The notebook includes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Magnetic translation group phase factors\nLandau level projection via form factors\nScreened Coulomb interaction: V(q) = W₀/|ql| * tanh(|qD|) * exp(-0.5*q²l²)\nMomentum conservation enforcement","category":"page"},{"location":"examples/#Example-2:-Bilayer-FQH-Halperin-State","page":"Examples","title":"Example 2: Bilayer FQH Halperin State","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"File: examples/example2_BilayerFQH_Halperin.ipynb","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This notebook extends the single-layer implementation to bilayer systems with layer degrees of freedom.","category":"page"},{"location":"examples/#Multi-component-System","page":"Examples","title":"Multi-component System","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The bilayer system uses:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Nc_hopping = 2: Two layers for hopping\nNc_conserve = 1: Single conserved quantity (total particles)\nLayer-dependent interactions: Different intra-layer and inter-layer couplings\nInter-layer tunneling: One-body terms between layers","category":"page"},{"location":"examples/#Key-Implementation-Details","page":"Examples","title":"Key Implementation Details","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Bilayer interaction function with layer conservation\nfunction V_int_bilayer(k_coords_f1, k_coords_f2, k_coords_i1, k_coords_i2, cf1=1, cf2=1, ci1=1, ci2=1)\n    # Layer conservation check\n    if ci1 != cf1 || ci2 != cf2\n        return 0.0 + 0.0im\n    end\n    \n    # k_coords_* are tuples (kx, ky) already normalized by Gk\n    q1 = k_coords_f1[1] - k_coords_i1[1]\n    q2 = k_coords_f2[1] - k_coords_i2[1]\n    \n    # Calculate base interaction using momentum coordinates\n    V_base = VFF(q1, q2)\n    \n    # Apply layer-dependent factors\n    if ci1 != ci2  # Different layers\n        ql_mag = sqrt(q1^2 + q2^2 - q1*q2) * Gl\n        V_base *= exp(-ql_mag * d_l)  # Inter-layer attenuation\n    end\n    \n    return V_base\nend","category":"page"},{"location":"examples/#One-body-Tunneling-Terms","page":"Examples","title":"One-body Tunneling Terms","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The notebook implements inter-layer tunneling:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# One-body Hamiltonian matrix: H_onebody[c1, c2, cc, k]\nH_onebody_bilayer = zeros(ComplexF64, Nc_hopping, Nc_hopping, 1, Nk)\n\n# Add tunneling terms: t = 0.5 * W0 between different layers\nfor k_idx in 1:Nk\n    H_onebody_bilayer[1, 2, 1, k_idx] = 0.5 * W0  # Layer 2 → Layer 1\n    H_onebody_bilayer[2, 1, 1, k_idx] = 0.5 * W0  # Layer 1 → Layer 2\nend","category":"page"},{"location":"examples/#Component-Indexing","page":"Examples","title":"Component Indexing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The notebook demonstrates the global orbital indexing scheme:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Global index = k + Nk * (ch - 1) + Nk * Nch * (cc - 1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Where:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"k: momentum index (1 to Nk)\nch: hopping channel index (1 to Nc_hopping)  \ncc: conserved component index (1 to Nc_conserve)","category":"page"},{"location":"examples/#Running-the-Examples","page":"Examples","title":"Running the Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To run these examples:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Install the package:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Pkg\nPkg.add(url=\"https://github.com/Zou-Bo/MomentumED.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Open the Jupyter notebooks in the examples/ directory\nExecute cells sequentially - each notebook is self-contained","category":"page"},{"location":"examples/#Key-Package-Features-Demonstrated","page":"Examples","title":"Key Package Features Demonstrated","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Both examples showcase:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Momentum Block Division: Automatic separation by total momentum quantum numbers\nScattering Formalism: Efficient Hamiltonian construction using scattering terms\nKrylovKit Integration: Sparse matrix diagonalization with convergence control\nMulti-component Support: Handling of additional quantum numbers beyond momentum\nEntanglement Analysis: Built-in functions for computing entanglement entropy with bit masks\nBerry Connection: Topological analysis capabilities between kshift points","category":"page"},{"location":"examples/#Performance-Considerations","page":"Examples","title":"Performance Considerations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The examples demonstrate:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Memory Efficiency: Bit-based state representation reduces memory usage\nSparse Methods: KrylovKit eigensolvers handle large sparse matrices efficiently\nBlock Diagonalization: Momentum conservation significantly reduces matrix sizes\nMulti-threading: Parallel Hamiltonian construction when available","category":"page"},{"location":"#MomentumED.jl","page":"Home","title":"MomentumED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: Documentation) (Image: Documentation) (Image: Code Style) (Image: License)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package for exact diagonalization with momentum conservation.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements exact diagonalization for quantum systems with momentum conservation. The Hamiltonian is block-diagonalized by total momentum sectors using KrylovKit for sparse matrix eigenvalue problems.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Momentum Block Division: Separates Hilbert space by total momentum quantum numbers\nBit-based State Representation: MBS64 type for many-body states using integer encoding\nScattering Formalism: Hamiltonian construction using one-body and two-body scattering terms\nKrylovKit Integration: Sparse matrix diagonalization using KrylovKit's eigsolve function\nMulti-component Systems: Support for conserved and non-conserved component indices\nEntanglement Calculation: Functions for computing entanglement entropy from eigenvectors\nBerry Connection: Many-body Berry connection calculation for topological analysis","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the package from GitHub:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/Zou-Bo/MomentumED.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides these main functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MomentumED\n\n# Define k-mesh for 2D system\nk_list = [0 1 2 0 1 2 0 1 2 0 1 2 0 1 2;\n          0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]\n\n# Define interaction function\nfunction V_int(k_coords_f1, k_coords_f2, k_coords_i1, k_coords_i2, cf1=1, cf2=1, ci1=1, ci2=1)\n    # k_coords_* are tuples (kx, ky) already normalized by Gk\n    # Your interaction potential here\n    return 1.0 + 0.0im  # Simple constant interaction\nend\n\n# Create parameter structure\npara = EDPara(k_list=k_list, Gk=(3, 5), V_int=V_int)\n\n# Generate many-body states for 4 particles\nmbs_list = ED_mbslist(para, 4)\n\n# Divide into momentum blocks\nblocks, block_k1, block_k2, k0number = ED_momentum_block_division(para, mbs_list)\n\n# Generate scattering lists\nscat_list1 = ED_sortedScatteringList_onebody(para)\nscat_list2 = ED_sortedScatteringList_twobody(para)\n\n# Solve first momentum block\nenergies, eigenvectors = EDsolve(blocks[1], scat_list1, scat_list2, 5)\n\nprintln(\"Ground state energy: \", energies[1])","category":"page"},{"location":"#Core-Components","page":"Home","title":"Core Components","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EDPara: Parameter container storing k-mesh, interaction functions, and component mappings\nMBS64{bits}: Many-body state representation with bit-based occupation encoding (up to 64 orbitals)\nScattering{N}: Hamiltonian term representation for efficient sparse matrix construction\nKrylovKit Integration: Uses eigsolve for sparse eigenvalue problems with configurable convergence","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KrylovKit: Sparse matrix eigenvalue solvers\nLinearAlgebra, SparseArrays: Core linear algebra functionality\nCombinatorics: Combinatorial utilities for state generation","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API Reference: Function signatures and usage\nExamples: Example notebooks and tutorials","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Example notebooks are included:","category":"page"},{"location":"","page":"Home","title":"Home","text":"examples/example1_FQH_Laughlin.ipynb\nexamples/example2_BilayerFQH_Halperin.ipynb","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License - see LICENSE file.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@software{MomentumED.jl,\n  author = {Zou, Bo},\n  title = {{MomentumED.jl}: A Julia Package for Exact Diagonalization with Momentum Conservation},\n  year = {2025},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/Zou-Bo/MomentumED.jl}}\n}","category":"page"}]
}
